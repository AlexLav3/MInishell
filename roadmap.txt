And it shell be light!!

//
links - sources 

https://www.cs.purdue.edu/homes/grr/SystemsProgrammingBook/Book/Chapter5-WritingYourOwnShell.pdf
https://medium.com/@muxanz/how-the-shell-works-internally-when-entering-a-command-42f08458870
https://0xax.gitbooks.io/linux-insides/content/SysCall/

//

basic commands and ctr stuff, history working, and no leaks so far, good job to us! XD

//
actual to-do -main
    handle quotes -> double ok, handle single.

    built in commands:
    missing: cd, export, unset
    ok so far: ls, echo, pwd, env, exit, (echo -n doesn't do anything as I see in normal bash, maybe edge cases?)

    piping
    redirection
    $
    $?
//
fixing 
    not typing anything and pressing enter = "command not found" - maybe fixed

    prompt> ls (space after ls) - fixed, now works no matter how many spaces you put after ls, with or without a flag.


// Ferenc 09/05/25
questions:
	In the sig.c  file:
	- identifier "SIGQUIT" is undefined same goes to SIGQUIT, SIG_IGN.
		Do we need to add something or it is just on my computer?
	- signal(SIGINT, sig_handle)
		Dont we need an int in the sig_handle call?

	According to the subject, we should have one global variable for signal, do you know anything about it?
	I have no clue how that is working. 

your questions/comments in the init.c files:
	- exit:
		yes, we can check if we can do that, the current one probably only works if the exit typed as first word,
		but I am not sure that correct, we need to research how exit command acts in terminal
	- pid as struct:
		well, due to pipe I had to chang them to structs at the end
	- take_comm to make shorter
		I will work on this now and see how we coudl split it. 
		Probaly start with removing the exit part :D

subject:
	exit with no options
	so it should be enough what we have, exit if the first word is "exit" command

// pipes and other stuff
	Implement the following redirections:
	◦ < should redirect input.
	◦ > should redirect output.
	◦ << should be given a delimiter, then read the input until a line containing the
	delimiter is seen. However, it doesn’t have to update the history!
	◦ >> should redirect output in append mode.
	• Implement pipes (| character). The output of each command in the pipeline is
	connected to the input of the next command via a pipe.

we need to create a condition to check if the command line has any of these signs and call different process according to that


// stuff done:
	take_comm was separated to different parts
		- "exit" check done by check_for_exit which is in clean_exit.c
		- created a new function called process_commands which took over the rest of the take_comm
		- tried to handle pipes, failed, at the end tried to get chatgpt fix it, failed
			for_pipes.c at the moment is not good
			for_pipes_utils.c has useful functions we maybe able to use for other seperators
		- builtin.c just a splace where we can do the next parts, not developed yet




