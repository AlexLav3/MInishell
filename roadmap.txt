And it shell be light!!

//
links - sources 

https://www.cs.purdue.edu/homes/grr/SystemsProgrammingBook/Book/Chapter5-WritingYourOwnShell.pdf
https://medium.com/@muxanz/how-the-shell-works-internally-when-entering-a-command-42f08458870
https://0xax.gitbooks.io/linux-insides/content/SysCall/

⚠️ = important issue (serious problem). even if fixes, check if happens on other edge cases/occasions.

-------------ISSUES AND FIXES-----------------

edge cases:

 echo - edges example which I am not sure we need to handle. This maybe something extra and we can skip. (fingers crossed)
	a command like : echo stuff"abcdef" $SHLVL'pizza'
	[echo ] -> [stuff] -> ["abcdef"] -> [""] (special tokens will have "" nodes instead of spaces) -> [$SHLVL] -> ['pizza']
		-bash behaviour: stuffabcdef 2pizza
		-minishell behaviour: stuff abcdef 2 pizza
to fix:

echo "$USER $USER"'hi'


other issues:
- memory leaks + seg faults for some edge cases + double free 
- minishell should be executable inside the minishell itself ?

-----------TO DO LIST-----------

-----LEAKS/ISSUES-----
1 bytes in 1 blocks are definitely lost in loss record 1 of 72
==647256==    at 0x4848899: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==647256==    by 0x496D5CE: strndup (strndup.c:43)
==647256==    by 0x404778: toks_to_args (make_args.c:53)
==647256==    by 0x40465A: make_args (make_args.c:31)
==647256==    by 0x401DD3: single_cmd (process_cmd.c:19)
==647256==    by 0x401F2C: process_commands (process_cmd.c:63)
==647256==    by 0x4014DB: take_comm (init.c:44)
==647256==    by 0x401334: main (main.c:28)
==647256== 
==647256== 2 bytes in 1 blocks are definitely lost in loss record 2 of 72
==647256==    at 0x4848899: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==647256==    by 0x405450: ft_strdup (ft_strdup.c:33)
==647256==    by 0x4048AD: handle_dollar (make_args.c:82)
==647256==    by 0x40474F: toks_to_args (make_args.c:51)
==647256==    by 0x40465A: make_args (make_args.c:31)
==647256==    by 0x401DD3: single_cmd (process_cmd.c:19)
==647256==    by 0x401F2C: process_commands (process_cmd.c:63)
==647256==    by 0x4014DB: take_comm (init.c:44)
==647256==    by 0x401334: main (main.c:28)
==647256== 
==647256== 7 bytes in 1 blocks are definitely lost in loss record 3 of 72
==647256==    at 0x4848899: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==647256==    by 0x405450: ft_strdup (ft_strdup.c:33)
==647256==    by 0x4046CF: toks_to_args (make_args.c:45)
==647256==    by 0x40465A: make_args (make_args.c:31)
==647256==    by 0x401DD3: single_cmd (process_cmd.c:19)
==647256==    by 0x401F2C: process_commands (process_cmd.c:63)
==647256==    by 0x4014DB: take_comm (init.c:44)
==647256==    by 0x401334: main (main.c:28)
==647256== 
==647256== LEAK SUMMARY:
==647256==    definitely lost: 10 bytes in 3 blocks
==647256==    indirectly lost: 0 bytes in 0 blocks
==647256==      possibly lost: 0 bytes in 0 blocks
==647256==    still reachable: 4,805 bytes in 70 blocks
==647256==         suppressed: 208,244 bytes in 225 blocks

--------------------18-05-26 notes ------------------------

Memory leak: 
Do we still have memory leak? It looked okay now when I have run valgrind. Can we delete notes above? no. we still have them

HEREDOC:
heredoc examples to check:
	if we need ot hadnle variables:
		name="Alice"
		cat << EOF
		Hi $name,
		Welcome to the shell!
		EOF
	result:
		Hi Alice,
		Welcome to the shell!

	redirecting to a file:
		cat << EOF > myfile.txt
		This will go into a file.
		Not just to the terminal.
		EOF
	
	using pipe:
		cat << EOF | grep "hello"
		hello bar
		ooo world
		here is is hello again
		EOF

	other command apart cat before heredoc:
		grep "bash" << EOF | sort
		zsh is nice
		bash is better
		fish is cool
		bash rocks
		EOF

PARSING:
Currently if we have a pipe, " mark or redirection without a trailing space, the next character will disappear. 
W is missing from wc
prompt> ls -a |wc -l
tokens com: ls
tokens com: -a
tokens com: |
tokens com: c
tokens com: -l
command not found: No such file or directory - not supposed to work 

B is missing from bash
prompt> grep "bash" << EOF | sort
tokens com: grep
tokens com: "
tokens com: ash
tokens com: "
tokens com: <<
tokens com: EOF
tokens com: |
tokens com: sort -leave quotes related issues aside for now

HISTORY:
Strange behaviour with the history.
If you go back with up arrow you will access the last commands, as you should.
But if you delete anything from that command line it will automatically update it in history.


-----------------------------------------------------------



------------------------------------------------------------------
Comment updates from slack about changes

builtin.c --> ft_export
	So this part was easy, just took out a part of the while loop and placed it into a separate function called set_var, which can be found utils2.c

envp_handle.c --> add_env
	Okay, this was trickier.
	So, as you mentioned yesterday copy_envp, I decided to go back to it. But it required a bit of modification due to the leak, and also because we use it in the init.c function.
	Now the copy_envp can copy env in the init, but also be used if there is a new Var.
	We call it with NULL in init, shell->env_var = copy_envp(envp, NULL);
	or with the new variable in add_env, new_envp = copy_envp(shell->env_var, var);
	A fast test showed no leaks, but I will test it again later once I finish with the rest of Norminette.
	I created a helper function called copy_env_vars and placed it in utils2.c. This actually makes the copy from envp to copy. While the copy_envp function handles the new variable after that, and added to the end.
	So maybe we should rename these functions a bit for more clarity? :thinking_face:

input.c --> make_tok
	Removed the unused variables.
	Added the frees to the returns, saving some lines.
	return (free(tks), -1);
	return (free(tks->builder), free(tks), -1);
	return (free(tks->builder), free(tks), i);
	no extra function was needed for this (edited) 

make_args.c --> handle_dollar
	Okay, so this was a bit harder due to the many variables.
	I managed to pass the if condition body to a helper function by using an extra struct variable, so the function has no more than 4.
	process_env_var(cmd, shell, prefix, i); was added to utils2.c
	apart the shell->env_idx = idx; line, there is no change in the function logic.

-------------------------------------------------------------------